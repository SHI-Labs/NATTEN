#!/bin/bash
# Copyright (c) 2022 - 2026 Ali Hassani.
#
# Parallel test runner for NATTEN unit tests
# Runs tests across multiple GPUs with dynamic load balancing
#
# Generated by Claude Code
#
# Usage: run_tests_parallel.sh [NUM_GPUS]
#   NUM_GPUS: Number of GPUs to use (default: 1)

set -e

# Parse arguments
NUM_GPUS=${1:-1}

# Default log level
export NATTEN_LOG_LEVEL="${NATTEN_LOG_LEVEL:-CRITICAL}"

# Always must be set for all tests
export PYTORCH_NO_CUDA_MEMORY_CACHING=1
export CUBLAS_WORKSPACE_CONFIG=":4096:8"

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${SCRIPT_DIR}/../.."
TEST_DIR="${PROJECT_ROOT}/tests"
LOG_DIR="${PROJECT_ROOT}/test-logs"
PYTEST="${PYTEST:-pytest}"

# Create log directory
mkdir -p "${LOG_DIR}"

# Get all test files
TEST_FILES=($(find "${TEST_DIR}" -name "test_*.py" -type f | sort))
TOTAL_TESTS=${#TEST_FILES[@]}

if [ ${TOTAL_TESTS} -eq 0 ]; then
    echo "No test files found in ${TEST_DIR}"
    exit 1
fi

echo "================================================="
echo "NATTEN Parallel Test Runner"
echo "================================================="
echo "Total tests: ${TOTAL_TESTS}"
echo "GPUs: ${NUM_GPUS}"
echo "Test directory: ${TEST_DIR}"
echo "Log directory: ${LOG_DIR}"
echo "================================================="
echo ""

# Function to run a single test
# This will be called by GNU parallel for each test file
run_single_test() {
    local test_file=$1
    local gpu_id=$((PARALLEL_JOBSLOT - 1))  # PARALLEL_JOBSLOT is 1-indexed
    local test_name=$(basename "${test_file}" .py)
    local log_file="${LOG_DIR}/${test_name}_gpu${gpu_id}.log"

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [GPU ${gpu_id}] Starting: ${test_name}"

    # Run test with specific GPU
    CUDA_VISIBLE_DEVICES=${gpu_id} ${PYTEST} -v -x "${test_file}" > "${log_file}" 2>&1
    local exit_code=$?

    if [ ${exit_code} -eq 0 ]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [GPU ${gpu_id}] ✓ PASSED: ${test_name}"
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [GPU ${gpu_id}] ✗ FAILED: ${test_name} (exit code: ${exit_code})"
    fi

    return ${exit_code}
}

# Export function and variables for GNU parallel
export -f run_single_test
export PYTEST LOG_DIR

# Create joblog file
JOBLOG="${LOG_DIR}/parallel_joblog.txt"

echo "Starting test execution with GNU parallel..."
echo ""

# Run tests in parallel using GNU parallel
# -j NUM_GPUS: run at most NUM_GPUS jobs in parallel
# --halt soon,fail=1: stop as soon as one job fails (like pytest -x)
# --line-buffer: print output line-by-line as it comes
# --joblog: track job execution details
# --tag: prefix output with argument (test filename)
printf '%s\n' "${TEST_FILES[@]}" | parallel \
    -j "${NUM_GPUS}" \
    --halt soon,fail=1 \
    --line-buffer \
    --joblog "${JOBLOG}" \
    run_single_test {}

# Capture parallel's exit code
PARALLEL_EXIT=$?

# Print summary
echo ""
echo "================================================="
echo "Test Summary"
echo "================================================="
echo "Total tests: ${TOTAL_TESTS}"

# Parse joblog to count passed/failed
# Joblog format: Seq Host Starttime JobRuntime Send Receive Exitval Signal Command
# Skip header line, count by exit code
if [ -f "${JOBLOG}" ]; then
    FAILED=$(awk 'NR>1 && $7!=0 {count++} END {print count+0}' "${JOBLOG}")
    PASSED=$((TOTAL_TESTS - FAILED))
else
    # Fallback if joblog doesn't exist
    FAILED=0
    PASSED=${TOTAL_TESTS}
fi

echo "Passed: ${PASSED}"
echo "Failed: ${FAILED}"
echo "================================================="

if [ ${PARALLEL_EXIT} -ne 0 ]; then
    echo ""
    echo "Failed tests:"
    # Extract failed test names from joblog
    awk 'NR>1 && $7!=0 {print $NF}' "${JOBLOG}" | while read test_path; do
        test_name=$(basename "${test_path}" .py)
        echo "  - ${test_name}"
    done
    echo ""
    echo "Check log files in ${LOG_DIR} for details"
    exit 1
else
    echo ""
    echo "All tests passed! ✓"
    exit 0
fi
